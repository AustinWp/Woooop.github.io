<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>武小鹏的博客</title>
  <icon>https://www.gravatar.com/avatar/47a2827b26ff5ad502be1618c2d474d1</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-09T07:16:54.756Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wooop</name>
    <email>allenwooop@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017至2018年度总结和规划</title>
    <link href="http://yoursite.com/2018/02/09/2017%E8%87%B32018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E5%92%8C%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2018/02/09/2017至2018年度总结和规划/</id>
    <published>2018-02-09T06:15:02.000Z</published>
    <updated>2018-02-09T07:16:54.756Z</updated>
    
    <content type="html"><![CDATA[<h4 id="2017至2018年度总结和规划"><a href="#2017至2018年度总结和规划" class="headerlink" title="2017至2018年度总结和规划"></a>2017至2018年度总结和规划</h4><p>​    按照传统的习惯，我还是比较喜欢使用农历来标记一年的结束，从小到大都是在鞭炮声中，一家人聚在一起度过辞旧迎新的时刻，这种仪式感是比较强的。马上就要放春假了，这时候是该做个总结和展望了。</p><h5 id="2017年度总结"><a href="#2017年度总结" class="headerlink" title="2017年度总结"></a>2017年度总结</h5><p>​    2017年是变化的一年，这一年，我从学校走向了工作单位，从长沙来到了杭州，这是关于工作的变化。在生活方面，在杭州落了定，也去了女朋友家面见了父母。应该说今年做的这几件事都很重要，可以说是人生一个阶段的里程碑。</p><p>​    2017年7月，进入了云课堂移动团队，周围同事无论是iOS还是安卓的同学都很棒，让我很快融入了这个环境，对云课堂2C项目的上手也是很迅速。在入职至今的几个月里，从啥都不了解的小白，很快成为项目熟手，虽说没有对项目整体的各个细节都了如指掌，但也是对绝大部分模块有一定的了解，对项目概括有一定的认识，在业务方面越来越熟，工作效率也越来越高。之后做了Weex相关的工作，这块在未来希望一方面是在项目中进行实际的应用，一方面进行更深入的研究。也对项目性能优化例如启动时间做了一定的研究，但是受限于客观问题，目前进展还不是特别明显。在本年度快要结束的时候担任了一次项目迭代负责人，虽然只是一次负责人的工作，但视野和自己作为单个开发完全不一样，责任感让自己对整个迭代的内容，进度，遇到的问题有个全局的认识。也锻炼了自己的统筹能力。希望在2018年把上面一些事情继续坚持做下去，做出成果。继续锻炼自己，使自己能够承担更多的压力，成为团队中更重要的角色，体现出自己更大的价值。</p><h5 id="2018年度展望"><a href="#2018年度展望" class="headerlink" title="2018年度展望"></a>2018年度展望</h5><p>​    说是年度展望，其实只想了前半年想要做的一些事情，具体后半年做什么根据前半年的结果在年中规划的时候再进行调整吧。</p><p>​    2018年是很重要的一年，如果说对我个人来说，2017年的半年是转型之年，那么2018年整年就是整体工作生涯夯实基础的一年。俗话说，基础不牢，地动山摇。所以我对自己的2018年总结为夯实基础的一年。那么我也在想，到底什么是基础呢，我觉得应该是两个方面来讲，第一，首先就是自己的业务能力，之前强哥也说过，没有经过业务的洗礼，怎么知道架构的需求呢，应该说优秀的架构师都是经过了大量的业务洗礼之后才能准确把握出在业务开发中的需求，从而进行架构的设计。第二，就是对通用技术的追求，何谓通用的技术，其实通用技术类似于网络，编译原理，系统线程进程，以及设计模式，代码结构，单元测试，这些和具体的工程领域不相关的计算机学科基础技术。这些东西无论做什么方向都会涉及。也是程序员真正的内功。所以希望在2018年能够进行基础的夯实。为整体的职业生涯打好一个开局。</p><p>​    2018年具体工作规划事项</p><p>​        1.学习Weex源码，了解Weex底层设计原理，以及回答上次分享有的同学提出的一些深层次的问题。整理起来做一次Weex分享第二part。</p><p>​        2.继续坚持在项目性能优化方面的工作，上次芳姐积分大人分享的时候也说过，项目性能优化，无他，扣细节尔。这方面之前做了些研究，但受限于客观存在的功能，一直进展不大，但是我会坚持下去，一有时间就继续尝试。</p><p>​        3.读两到三个优秀的开源库源码，至于读什么还没选择好。数量不在多，优秀就好。</p><p>​        4.读书《代码整洁之道》《重构，改善既有代码的设计》前两本书就不用多说了，经典值得反复品读。《程序员的自我修养》这本前几天看见骥文在读，借过来读了十几页觉得蛮不错的，对计算机的整体原理做了一次梳理，对各种编译，链接，操作系统底层如何工作等等，值得一读，有助于作为和机器打交道的程序开发理解机器到底是怎么工作的。</p><p>​    新年马上就要来了，给自己定了一点点小目标，希望在🐶年各项事情能更顺利，在生活上迈出新的篇章，在工作上登上新的台阶。2018，请为自己加油！    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;2017至2018年度总结和规划&quot;&gt;&lt;a href=&quot;#2017至2018年度总结和规划&quot; class=&quot;headerlink&quot; title=&quot;2017至2018年度总结和规划&quot;&gt;&lt;/a&gt;2017至2018年度总结和规划&lt;/h4&gt;&lt;p&gt;​    按照传统的习惯，我
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>保证用户拿到的内容没有被篡改的验证方法</title>
    <link href="http://yoursite.com/2017/11/23/%E4%BF%9D%E8%AF%81%E7%94%A8%E6%88%B7%E6%8B%BF%E5%88%B0%E7%9A%84%E5%86%85%E5%AE%B9%E6%B2%A1%E6%9C%89%E8%A2%AB%E7%AF%A1%E6%94%B9%E7%9A%84%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/11/23/保证用户拿到的内容没有被篡改的验证方法/</id>
    <published>2017-11-23T03:18:21.516Z</published>
    <updated>2017-11-23T03:18:21.516Z</updated>
    
    <content type="html"><![CDATA[<p>用户拿到的内容没有被篡改的验证：</p><p>1.服务器生成公私钥</p><p>2.服务器公布公钥</p><p>3.服务器对即将发布的数据进行MD5，使用私钥对MD5后生成的字符串进行加密，生成的东西称之为签名</p><p>4.服务器把这个签名和本来要发的数据一起发给用户</p><p>5.用户收到所有数据后，用公钥解密签名，得到MD5字符串，</p><p>6.用户再对原始数据进行MD5，然后两个MD5字符串比对以验证原始数据在发送的过程中是否有没有被篡改过</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用户拿到的内容没有被篡改的验证：&lt;/p&gt;
&lt;p&gt;1.服务器生成公私钥&lt;/p&gt;
&lt;p&gt;2.服务器公布公钥&lt;/p&gt;
&lt;p&gt;3.服务器对即将发布的数据进行MD5，使用私钥对MD5后生成的字符串进行加密，生成的东西称之为签名&lt;/p&gt;
&lt;p&gt;4.服务器把这个签名和本来要发的数据一起发
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>什么样代码是好的？对于编写代码，人们常常会出现哪些误区？</title>
    <link href="http://yoursite.com/2017/11/23/%E4%BB%80%E4%B9%88%E6%A0%B7%E4%BB%A3%E7%A0%81%E6%98%AF%E5%A5%BD%E7%9A%84%EF%BC%9F%E5%AF%B9%E4%BA%8E%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BA%BA%E4%BB%AC%E5%B8%B8%E5%B8%B8%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%93%AA%E4%BA%9B%E8%AF%AF%E5%8C%BA%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/11/23/什么样代码是好的？对于编写代码，人们常常会出现哪些误区？/</id>
    <published>2017-11-23T03:18:21.516Z</published>
    <updated>2017-11-23T03:18:21.516Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么样代码是好的？对于编写代码，人们常常会出现哪些误区？"><a href="#什么样代码是好的？对于编写代码，人们常常会出现哪些误区？" class="headerlink" title="什么样代码是好的？对于编写代码，人们常常会出现哪些误区？"></a>什么样代码是好的？对于编写代码，人们常常会出现哪些误区？</h5><ul><li><p>代码是更多时间是用来维护的，其次才是实现功能的</p></li><li><p>好的代码是可以进行良好的自我描述的，并不需要太多的注释，为了代码更好的维护，在无法写出一目了然的代码的时候，必要的注释是不能少的。切勿不能代码逻辑既复杂，还没有相应的注释或者文档说明。</p></li><li><p>所有的设计模型和理论都只是手段，其实唯一的目标是在尽量提高（可维护性，可复用性=可测试性）等等的条件下实现业务需求。切不可形而上学，走教条主义，一味的追求固话的设计模式从而使得代码复杂难以理解和测试。</p><h5 id="那么如何写出好的代码？"><a href="#那么如何写出好的代码？" class="headerlink" title="那么如何写出好的代码？"></a>那么如何写出好的代码？</h5><ul><li>code review  重点不是机器可以检查出来的代码错误或者一些细微的编写习惯，重点是代码的设计思路和模块的划分方法，对于实际情况中，小团队的集体重构是一个很好的选择</li><li>代码重构</li><li>阅读优秀的开源代码，或者组内优秀同学写出的代码，阅读自己身边人的代码好处是可以问问他们为什么这样写，为什么那样写，进步会很快。</li><li>最后是使用一些静态代码检查的工具进行代码检查。</li></ul><h5 id="常用的代码整洁技巧："><a href="#常用的代码整洁技巧：" class="headerlink" title="常用的代码整洁技巧："></a>常用的代码整洁技巧：</h5><ul><li>任何一个东西（class method var）都应该明确的负责某个单一概念的事情。</li><li>在编写一个功能点之前，对其实现方式进行一个大体的设计（如果是强数据相关的话，在脑海中把数据流串起来，必要的时候可以使用状态机的概念跟踪APP的变化），然后再完成细节实现代码。</li><li>类，方法，变量，名称的设计，函数和方法参数的设计，目的是尽量靠近让人一目了然的效果</li><li>对于任何的方法和类，无论是UI相关还是网络相关还是逻辑相关或者是数据处理相关，都必须准确的找到一个类的归属，并且这个归属是师出有名的。这就需要一个良好的概念定义和设计，（具体就是指，这些事情怎么分块，放在哪，之间怎么依赖）</li><li>对复杂继承的使用保持慎独的态度，如果套东西使用复杂继承关系并不是必要的，那么尽量不要使用。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;什么样代码是好的？对于编写代码，人们常常会出现哪些误区？&quot;&gt;&lt;a href=&quot;#什么样代码是好的？对于编写代码，人们常常会出现哪些误区？&quot; class=&quot;headerlink&quot; title=&quot;什么样代码是好的？对于编写代码，人们常常会出现哪些误区？&quot;&gt;&lt;/a&gt;什么
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WebRTC-编译以及运行IOS的Demo</title>
    <link href="http://yoursite.com/2017/11/23/WebRTC-%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8CIOS%E7%9A%84Demo/"/>
    <id>http://yoursite.com/2017/11/23/WebRTC-编译以及运行IOS的Demo/</id>
    <published>2017-11-23T03:18:21.505Z</published>
    <updated>2017-11-23T03:18:21.505Z</updated>
    
    <content type="html"><![CDATA[<p>注：本篇文章的前提是，你已经下载好官方8G多的源代码，如还没有得到代码，请参照其他攻略先下载好代码。此外需说明下，我的系统环境为Mac OSX 10.11.4</p><p>（1）下载安装ninja（如已安装，则可跳过这一步）：<br>因为Xcode是不能直接编译webRTC的代码的，必须使用ninja。</p><ul><li><p>获得并编译ninja的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git clone git://github.com/martine/ninja.git</div><div class="line">$ cd ninja/</div><div class="line">$ ./bootstrap.py</div></pre></td></tr></table></figure></li><li><p>上述步骤会在当前目录下产生一个ninja的可运行文件。使用以下命令把它复制到/usrlocal/bin下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo cp ninja /usr/local/bin/</div><div class="line">$ sudo chmod a+rx /usr/local/bin/ninja</div></pre></td></tr></table></figure></li></ul><p>（2）配置需要的编译的目标环境</p><ul><li>cd 至下载好的源代码的src目录下，其实就是主目录就这一个大文件夹。</li><li><p>配置命令，以下命令根据demo的需要情况，只选其中一种执行，根据不同的情况，最后输出的demo也不一样。</p><ul><li><p>32位真机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export GYP_DEFINES=&quot;OS=ios target_arch=arm&quot;</div><div class="line">export GYP_GENERATOR_FLAGS=&quot;output_dir=out_ios&quot;</div></pre></td></tr></table></figure></li><li><p>64位真机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export GYP_DEFINES=&quot;OS=ios target_arch=arm64&quot;</div><div class="line">export GYP_GENERATOR_FLAGS=&quot;output_dir=out_ios64&quot;</div></pre></td></tr></table></figure></li><li><p>32位模拟器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export GYP_DEFINES=&quot;OS=ios target_arch=ia32&quot;</div><div class="line">export GYP_GENERATOR_FLAGS=&quot;output_dir=out_sim&quot;</div></pre></td></tr></table></figure></li><li><p>64位模拟器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export GYP_DEFINES=&quot;OS=ios target_arch=x64&quot;</div><div class="line">export GYP_GENERATOR_FLAGS=&quot;output_dir=out_sim&quot;</div></pre></td></tr></table></figure></li><li><p>OSX</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export GYP_DEFINES=&quot;OS=mac target_arch=x64&quot;</div><div class="line">export GYP_GENERATOR_FLAGS=&quot;output_dir=out_mac&quot;</div></pre></td></tr></table></figure></li></ul></li><li><p>执行完上面的配置命令后 执行脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webrtc/build/gyp_webrtc.py</div></pre></td></tr></table></figure></li></ul><p>（3）编译运行demo</p><ul><li><p>这里有两种方式，第一种，使用ninja命令直接编译运行，第二种，生成xcode工程，在xcode里运行，但实际上并不是xcode编译的，而实际上还是运行了第一种的命令脚本。只不过使用xcode可以看见一些源代码，比较清晰些</p></li><li><p>直接编译运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ninja -C out_ios/Debug-iphoneos AppRTCDemo</div><div class="line">ninja -C out_ios/Release-iphoneos AppRTCDemo</div><div class="line">ninja -C out_sim/Debug-iphonesimulator AppRTCDemo</div></pre></td></tr></table></figure></li><li><p>生成xcode编译运行</p><ul><li><p>还是配置一下环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export GYP_GENERATOR_FLAGS=&quot;xcode_project_version=3.2 xcode_ninja_target_pattern=All_iOS xcode_ninja_executable_target_pattern=AppRTCDemo|libjingle_peerconnection_unittest|libjingle_peerconnection_objc_test output_dir=out_ios&quot;</div><div class="line">export GYP_GENERATORS=&quot;ninja,xcode-ninja&quot;</div></pre></td></tr></table></figure></li><li><p>还是要再执行一下上面那个脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webrtc/build/gyp_webrtc.py</div></pre></td></tr></table></figure></li><li><p>执行完后再src目录下就是生成一个all.ninja.xcworkspace工程，打开后会根据你在之前配置的情况生成不同的target，后面就可以command+R运行就好了，上面配置的是真机的话也是可以的。</p></li></ul></li></ul><p>（4）测试demo</p><ul><li>在真机装一个demo（因为真机有摄像头）</li><li>用谷歌或火狐浏览器打开<br><a href="https://apprtc.appspot.com/" target="_blank" rel="external">https://apprtc.appspot.com/</a>  需要翻墙</li><li>两边同时进入同一个房间号即可连接。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注：本篇文章的前提是，你已经下载好官方8G多的源代码，如还没有得到代码，请参照其他攻略先下载好代码。此外需说明下，我的系统环境为Mac OSX 10.11.4&lt;/p&gt;
&lt;p&gt;（1）下载安装ninja（如已安装，则可跳过这一步）：&lt;br&gt;因为Xcode是不能直接编译webRT
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>与Weex的第一次亲密接触—初识</title>
    <link href="http://yoursite.com/2017/11/20/%E4%B8%8EWeex%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BA%B2%E5%AF%86%E6%8E%A5%E8%A7%A6%E2%80%94%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2017/11/20/与Weex的第一次亲密接触—初识/</id>
    <published>2017-11-20T01:39:15.000Z</published>
    <updated>2017-11-23T03:18:21.506Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Weex—初识"><a href="#Weex—初识" class="headerlink" title="Weex—初识"></a>Weex—初识</h4><p>​    大前端统一开发方案当前在市场上有很多，从去年的ReacNative特别火，到后来阿里推出的Weex等，一直想从某种角度入手去学习一些除iOS原生开发之外的一些东西，经过对比之后，感觉Weex比较适合，她的优势是轻量，灵活，和原生一样的流畅度，热更新，三端统一，但是缺点也很明显，也是RN一样具有的，不能全面的覆盖移动端的特性，每年移动端都会出一些新的特性，比如今年推出的人脸识别。此外，在性能方面可能会有些许差异，关于这个具体后面我会做一些实验，总结出一篇文章出来。</p><p>​    那么闲话不多说我们开始。</p><h5 id="环境要求："><a href="#环境要求：" class="headerlink" title="环境要求："></a>环境要求：</h5><ul><li>macOS</li><li>Homebrew</li></ul><ul><li>Node</li><li>Npm</li><li>Xcode (编译iOS)</li><li>Android Studio （编译安卓）</li><li>Weex-toolkit</li><li>Weexpack</li></ul><p>是不是站一看有点多，没关系，我一条一条慢慢说，因为我个人使用的环境是Mac，所以以下配置过程都是在Mac中完成的，请酌情参考。</p><p>​    Homebrew是Mac系统平台上的包管理器，是神器，墙裂建议安装。不过这里你也必须安装~。~，假如你的Mac上没有安装Homebrew,请先安装。安装方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure><p>​    Node.js是一个基于Chrome V8引擎的JavaScript运行环境，编译JS代码需要的环境。这一步就需要上面brew安装完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install node</div></pre></td></tr></table></figure><p>​    安装完成后检测是否安装成功，建议安装至最新版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node -v</div><div class="line">npm -v</div></pre></td></tr></table></figure><p><img src="/2017/11/20/与Weex的第一次亲密接触—初识/node-v.png" alt="">    </p><p>​    Npm是Node自带的包管理工具，类似于iOS领域中的Pod，在我们安装Node的时候也会把npm安装上。可以设置npm镜像加速下面步骤的速度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm config set registry https://registry.npm.taobao.org --global</div><div class="line">npm config set disturl https://npm.taobao.org/dist --global</div></pre></td></tr></table></figure><p>​    Xcode和Android Studio都是为了编译不同平台的工具。</p><p>​    Weex-toolkit是官方的一个工具，可以用来创建，调试，打包Weex项目。这里有个巨坑，如果遇到权限问题千万不要使用sudo安装，sudo安装会导致后面不能调试等一系列问题。如果在不使用sudo的时候还遇到权限问题，参考GitHub的weex-toolkit的QA部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g weex-toolkit</div></pre></td></tr></table></figure><p>​    安装成功后是这样子的，我这里有个提示更新的提示，正常的话应该是没有。<img src="/2017/11/20/与Weex的第一次亲密接触—初识/weex.png" alt="weex"></p><p>​    Weexpack是新一代的weex应用工程和插件工程开发套件，是基于weex快速搭建应用原型的利器。它能够帮助开发者通过命令行创建weex应用工程和插件工程，快速打包 weex 应用并安装到手机运行，对于具有分享精神的开发者而言还能够创建weex插件模版并发布插件到weex应用市场。 使用weexpack 能够方便的在在weex工程和native工程中安装插件。</p><p>​    简单的说，如果使用Weex做单页面那么Weex-toolkit就可以了，如果整个App都使用Weex开发，那么Weexpack比较方便，并且在调试不同平台的时候，个人觉得比较好用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g weexpack //全局安装</div></pre></td></tr></table></figure><h5 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h5><p>​    配置好环境之后，我们就可以使用weexpack开始创建工程了。使用weexpack可以让我们快捷的生成iOS和安卓平台的工程模板，目的是在各自平台的模拟器或者真机上可以查看 Weex 运行的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">weexpack create 你的工程名</div></pre></td></tr></table></figure><p>​    生成好工程之后cd，进入工程目录里面，进行npm install安装一些依赖包，这一步有点像iOS上面的pod install。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd 你的工程名</div><div class="line">npm install</div></pre></td></tr></table></figure><p>​    这就是生成好的项目目录结构。</p><p><img src="/2017/11/20/与Weex的第一次亲密接触—初识/image-index.png" alt=""></p><p>​    上面提到过，我们可以使用weexpack生成iOS和安卓平台的工程模板。输入下面的命令后，我们可以在工程目录里的platforms里发现相关代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">weexpack platform add ios</div><div class="line">weexpack platform add android</div></pre></td></tr></table></figure><p>​    刚才生成的工程里的helloweex代码就是位于/src/index.vue文件里，Weex使用了Vue框架，所以这里也是Vue类型的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div class=&quot;wrapper&quot; @click=&quot;update&quot;&gt;</div><div class="line">    &lt;image :src=&quot;logoUrl&quot; class=&quot;logo&quot;&gt;&lt;/image&gt;</div><div class="line">    &lt;text class=&quot;title&quot;&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt;</div><div class="line">    &lt;text class=&quot;desc&quot;&gt;Now, let&apos;s use vue to build your weex app.&lt;/text&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;style&gt;</div><div class="line">  .wrapper &#123; align-items: center; margin-top: 120px; &#125;</div><div class="line">  .title &#123; padding-top:40px; padding-bottom: 40px; font-size: 48px; &#125;</div><div class="line">  .logo &#123; width: 360px; height: 156px; &#125;</div><div class="line">  .desc &#123; padding-top: 20px; color:#888; font-size: 24px;&#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">  export default &#123;</div><div class="line">    data: &#123;</div><div class="line">      logoUrl: &apos;http://img1.vued.vanthink.cn/vued08aa73a9ab65dcbd360ec54659ada97c.png&apos;,</div><div class="line">      target: &apos;World&apos;</div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">      update: function (e) &#123;</div><div class="line">        this.target = &apos;Weex&apos;</div><div class="line">        console.log(&apos;target:&apos;, this.target)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h5 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h5><p>​    首先我们看一下在web端运行的效果，建议都加上sudo权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm run build //源码打包，生成 JS Bundle</div><div class="line">npm run dev //webpack watch 模式，方便开发</div><div class="line">npm run serve //开启HotReload服务器，代码改动的将会实时同步到网页中</div></pre></td></tr></table></figure><p>​    打包成功</p><p><img src="/2017/11/20/与Weex的第一次亲密接触—初识/dabaochenggong.png" alt="">          </p><p>​    web运行效果</p><p><img src="/2017/11/20/与Weex的第一次亲密接触—初识/webbuild.png" alt=""></p><p>​    web运行成功之后我们去试试模拟器的运行效果，因为目前博主只是安装了Xcode，所以就试一下在iOS平台的效果吧。官方的指令weex run ios命令问题很多，我们只使用build命令，运行还是自己手动去运行，当然在执行build命令之前，前面的add platform命令是前置条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">weex build ios</div></pre></td></tr></table></figure><p>​    在运行到需要输入APPID的时候control+c退出，这里可以自己使用xcode自由修改。</p><p><img src="/2017/11/20/与Weex的第一次亲密接触—初识/podinstall.png" alt=""></p><p>​    build之后我们就可以去找生成好的代码运行了。位置在platforms/ios/weexDemo.xcworkspace打开使用xcode运行。</p><p><img src="/2017/11/20/与Weex的第一次亲密接触—初识/ios.png" alt=""></p><p>至此我们已经进入了weex。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Weex—初识&quot;&gt;&lt;a href=&quot;#Weex—初识&quot; class=&quot;headerlink&quot; title=&quot;Weex—初识&quot;&gt;&lt;/a&gt;Weex—初识&lt;/h4&gt;&lt;p&gt;​    大前端统一开发方案当前在市场上有很多，从去年的ReacNative特别火，到后来阿里推出的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>同一台电脑配置多个SSHKey</title>
    <link href="http://yoursite.com/2017/09/18/%E5%90%8C%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSHKey/"/>
    <id>http://yoursite.com/2017/09/18/同一台电脑配置多个SSHKey/</id>
    <published>2017-09-18T08:36:45.000Z</published>
    <updated>2017-11-23T03:18:21.516Z</updated>
    
    <content type="html"><![CDATA[<h5 id="同一台电脑配置多个SSHKey"><a href="#同一台电脑配置多个SSHKey" class="headerlink" title="同一台电脑配置多个SSHKey"></a>同一台电脑配置多个SSHKey</h5><p>公司有自己的GitLab，但是我平时也喜欢给GitHub上放点东西，包括这个博客就是在GitHub托管的。因为在部署博客的时候只能使用SSH，所以就需要在公司电脑上配置两个SSHKey，那么到底我们在使用SHH的时候，它用的是哪个Key呢。在经过学习后发现SSH有一个config文件可以配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># GitHub的配置信息</div><div class="line">Host github.com</div><div class="line">HostName ssh.github.com</div><div class="line">Port 443</div><div class="line">PreferredAuthentications publickey</div><div class="line">IdentityFile ~/.ssh/github_rsa  //对应为GitHub生成的KEY</div><div class="line"></div><div class="line"></div><div class="line"># 自己公司的配置信息</div><div class="line">Host 公司Git的host</div><div class="line">HostName 公司Git的hostname</div><div class="line">PreferredAuthentications publickey</div><div class="line">IdentityFile ~/.ssh/id_rsa //对应为公司Git生成的KEY</div></pre></td></tr></table></figure><p>用上面内容创建一个名为config的文件，放入~/.ssh目录里面即可。</p><p>下面是我的~/.ssh目录里面的东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">configgithub_rsa.pubid_rsa.pub</div><div class="line">github_rsaid_rsaknown_hosts</div></pre></td></tr></table></figure><h5 id="写一个切换Git用户名邮箱信息的小脚本"><a href="#写一个切换Git用户名邮箱信息的小脚本" class="headerlink" title="写一个切换Git用户名邮箱信息的小脚本"></a>写一个切换Git用户名邮箱信息的小脚本</h5><p>有这么一个需求，就是我经常会在公司Git和GitHub切换提交东西，我希望我能快速切换Git账号信息和邮箱信息，所以就写了一个shell小脚本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">if [[ $1 == "g" ]]; then</div><div class="line"><span class="meta">#</span>statements</div><div class="line">git config --global user.email allenwooop@gmail.com</div><div class="line">    git config --global user.name Woooop</div><div class="line">echo "设置Git邮箱为allenwooop@gmail.com"</div><div class="line">fi</div><div class="line">if [[ $1 == "p" ]]; then</div><div class="line"><span class="meta">#</span>statements</div><div class="line">git config --global user.email 私有邮箱</div><div class="line">    git config --global user.name 私有name</div><div class="line">echo "设置Git邮箱为xxxx@mail.com"</div><div class="line">fi</div></pre></td></tr></table></figure><p>使用方法：自己创建一个.sh的文件，把代码粘贴进去，填写自己对应的信息。</p><p>切换为GitHub邮箱环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./文件名.sh g //g是参数，代表GitHub</div></pre></td></tr></table></figure><p>切换为私有邮箱环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./文件名.sh p //p是参数，代表私有环境Private</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;同一台电脑配置多个SSHKey&quot;&gt;&lt;a href=&quot;#同一台电脑配置多个SSHKey&quot; class=&quot;headerlink&quot; title=&quot;同一台电脑配置多个SSHKey&quot;&gt;&lt;/a&gt;同一台电脑配置多个SSHKey&lt;/h5&gt;&lt;p&gt;公司有自己的GitLab，但是我平时
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重读SDWebImage</title>
    <link href="http://yoursite.com/2017/09/18/%E9%87%8D%E8%AF%BBSDWebImage/"/>
    <id>http://yoursite.com/2017/09/18/重读SDWebImage/</id>
    <published>2017-09-18T01:51:53.000Z</published>
    <updated>2017-11-23T03:18:21.517Z</updated>
    
    <content type="html"><![CDATA[<h4 id="重读SDWebImage"><a href="#重读SDWebImage" class="headerlink" title="重读SDWebImage"></a>重读SDWebImage</h4><p>很早以前刚接触iOS开发的时候就知道SDWebImage的强大和流行，在大部分的iOS项目中都可以看到她的身影，也是相当经典的第三方库，非常值得阅读，只是一直以来都只是大致了解其运行的流程，并没有深入阅读源码，其中的许多设计和细节都非常值得学习，所以让我们再次去一探究竟。</p><p>首先我们从一张时序图来了解SDWebImage最主要的工作流程。<img src="/2017/09/18/重读SDWebImage/SDWebImageSequenceDiagram.png" alt=""></p><p>其工作流程可以分为下列的步骤：</p><ol><li>控件调用setImageWithURL接口</li><li>追溯到UIView的loadImageWithURL方法</li><li>在SDWebImageManager中首先通过queryDiskCacheForKey方法寻找所请求的图片是否在沙盒中缓存</li><li>如果有，则直接返回Image，否则通过downloadImage方法使用另外一个类SDWebImageDownloader下载图片，返回结果后，通过storeImage缓存图片，而后再返回Image</li><li>把Image数据set到相应的控件上</li></ol><p>了解了基本流程后，我们再看看具体的类结构。<img src="/2017/09/18/重读SDWebImage/SDWebImageClassDiagram.png" alt=""></p><p>初看起来是比较复杂的一张类图，但仔细看看后可以发现其实他们之间的关系是比较清晰的。</p><ul><li>首先我们从左上角开始看起，对UIButton、UIImageView等控件添加分类方法作为下载图片的入口，所有的方法最终走他们父类UIview的方法sd_internalSetImage</li><li>SDWebImageManager 作为连接所有类的核心，在sd_internalSetImage方法中通过调用loadImageWithURL进入。</li><li>SDWebImageCombinedOperation 描述的是一个在Manager层面的下载操作，里面包含了取消block还有真正的下载操作Operation。</li><li>SDWebImageManagerDelegate 提供一些代理方法给外部使用</li><li>SDImageCache 看其名字就知道是提供缓存功能的</li><li>SDImageCacheConfig 配置缓存设置信息的属性及方法</li><li>SDWebImageDownloader 看其名字也知道是用来下载图片的</li><li>SDWebImageDownloaderOperation 一个真正的下载任务</li><li>SDWebImageDownloadToken 用来描述一个下载任务的特征</li><li>SDWebImageDownloaderOperationInterface 如果想要自定义一个下载任务的话，必须遵守的协议</li><li>SDWebImagePrefetcher 用来预下载图片的，可以下载完先不使用</li></ul><p>这么多类中，其实支撑SDWebImage运作的最主要的三个部分，他们分别是：SDWebImageManager、SDImageCache、SDWebImageDownloader下面我们逐一对其进行细细分析，看看他们到底是怎么工作的。</p><h5 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h5><p>如果我们查看SDWebImageManager.m的源码，会发现其中近一半多的篇幅都被单独一个方法占据了，他就是之前我们提过的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url options:(SDWebImageOptions)options progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure><p>很明显这个方法中的内容是SDWebImageManager中最核心的工作流程，下面我们逐一梳理其中的逻辑。</p><ol><li><p>检查URL的合法性</p></li><li><p>检查URL是否曾经失败过</p></li><li><p>结合上面的信息，选择是否提前回调。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>] url:url];</div></pre></td></tr></table></figure></li><li><p>根据URL获取CacheKey，通过CacheKey去本地寻找图片，现在内存中找，如果内存中没有就去沙盒中找，这里使用了GCD异步函数，专门在一个IO线程里做沙盒存取的操作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock &#123;</div><div class="line">    <span class="comment">// First check the in-memory cache...</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="built_in">NSData</span> *diskData = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">if</span> ([image isGIF]) &#123;</div><div class="line">            diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(image, diskData, SDImageCacheTypeMemory);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="comment">// do not call the completion if cancelled</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></li><li><p>如果缓存中有，则回调，没有的话则去网络下载</p><p> 这里有个值得一说的点就是作者通过位移运算符做SDWebImageDownloaderOptions的枚举值，通过对枚举值进行或运算可以通过一个值描述多个枚举。</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SDWebImageDownloaderLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">0</span> <span class="comment">//00000001</span></div><div class="line">SDWebImageDownloaderProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">1</span> <span class="comment">//00000010</span></div><div class="line">SDWebImageDownloaderUseNSURLCache = <span class="number">1</span> &lt;&lt; <span class="number">2</span> <span class="comment">//00000100</span></div><div class="line">options =  SDWebImageDownloaderLowPriority || SDWebImageDownloaderProgressiveDownload || SDWebImageDownloaderUseNSURLCache</div><div class="line">options = <span class="number">00000111</span></div></pre></td></tr></table></figure><p> 设置好配置信息后去网络下载</p></li><li><p>如果下载成功后就把图片cache起来，然后回调</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">[<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];&#125;</div><div class="line">[<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</div></pre></td></tr></table></figure></li></ol><p>以上就是SDWebImageManager的主要功能和流程，在这其中包含了对imageCache和imageDownloader的调用，下面我们就先说一说imageCache。</p><h5 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h5><p>其实SDImageCache的功能很简单，就是对图片的缓存，缓存有两个地方，一个是内存memory，另外一个是沙盒disk。SDImageCache分别提供了对这两个地方进行图片的存、取、删的功能。我们就通过逐一介绍这些方法作为切入点对SDImageCache进行分析。</p><ul><li><p>存储Store</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</div><div class="line">         imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</div><div class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</div><div class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</div><div class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock;</div></pre></td></tr></table></figure><p>这些参数都很好理解，如果cacheconfig中设置了缓存在内存中，则先回把数据缓存进内存，然后再缓存至disk沙盒中。[self checkIfQueueIsIOQueue]检查当前queue是不是IOqueue。然后再把数据写入对应的路径中。</p></li><li><p>取Query</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock;</div></pre></td></tr></table></figure><p>最主要的方法就是这个，其中先去内存中寻找，如果没有命中，则异步去disk中再找，如果找到的话，则把当前图片缓存在内存里方便下一次寻找的的同时，返回图片。</p></li><li><p>删除Remove</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key fromDisk:(<span class="built_in">BOOL</span>)fromDisk withCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion</div></pre></td></tr></table></figure><p>删除逻辑就比较简单了，如果是cacheconfig是shouldCacheImagesInMemory的话，先删除内存中的，再异步删除disk中的数据，然后跳回主线程执行回调。</p></li></ul><h5 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h5><p>在SDWebImage中另一个非常重要的部分就是下载器SDWebImageDownloader了，总体其使用了NSURLSession和NSOperation进行设计和实现。下面这个方法就是整个下载器最主要的了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url options:(SDWebImageDownloaderOptions)options progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock;</div></pre></td></tr></table></figure><p>这个方法首先会转入一个新的方法addProgressCallback，并且直接返回其的返回值。在addProgressCallback中会根据URL去URLOperations里面寻找是否有对应的Operation,没有的话，则把createCallback赋值给Operation。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">operation = createCallback();</div></pre></td></tr></table></figure><p>并且加入到数组URLOperations中保存。在URLOperations的完成回调函数里写，在Operation执行完毕后，从URLOperations中删除。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line">token = [SDWebImageDownloadToken new];</div><div class="line">token.url = url;</div><div class="line">token.downloadOperationCancelToken = downloadOperationCancelToken;</div></pre></td></tr></table></figure><p>通过addHandlersForProgress方法，把过程回调progressBlock和完成回调completedBlock封装在一个downloadOperationCancelToken里面，并且在callbackBlocks中保存。然后再生成一个SDWebImageDownloadToken，分别包含URL和Token信息。最终返回Token</p><p>那么到这里，让我们看看前面createCallback()中到底做了什么？</p><p>在createCallback()中，我们根据options设置了request的缓存策略</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLRequestCachePolicy</span> cachePolicy = <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>;</div><div class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderUseNSURLCache) &#123;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123;</div><div class="line">                cachePolicy = <span class="built_in">NSURLRequestReturnCacheDataDontLoad</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                cachePolicy = <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>生成了request，设置requestheader，cookies</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval];</div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</div><div class="line">        <span class="keyword">if</span> (sself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders <span class="keyword">copy</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.HTTPHeaders;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>根据request和session生成SDWebImageDownloaderOperation。对Operation的一些属性进行设置，例如credentials（认证），queuePriority（队列中优先级）等等。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</div></pre></td></tr></table></figure><p>最后加入到downloadQueue队列中，并且添加上一个加入的lastAddedOperation对当前Operation的依赖。保证先进后出的顺序。（可以想象一下，你快速刷新Tableview的时候，同时有很多图片下载，但是如果是FIFO的话，你已经在底部了，图片还是从上往下，按照请求的顺序返回是不是不合理，合理的应该是你当前眼睛看到的那部分图片，也就是最后发出的那些请求先返回，这样就很好理解了。）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[sself.downloadQueue addOperation:operation];</div><div class="line">        <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            [sself.lastAddedOperation addDependency:operation];</div><div class="line">            sself.lastAddedOperation = operation;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>最后返回operation。</p><p>此外，还有另外一个方法，就是取消任务的功能。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)cancel:(<span class="keyword">nullable</span> SDWebImageDownloadToken *)token</div></pre></td></tr></table></figure><p>首先进入到dispatch_barrier_async中执行任务，栅栏函数的作用是，在其队列中，保证在其之前的所有任务都执行完毕后才会执行，并且在其执行完毕后，后面的其他任务才能正常执行。倘若一个队列中所有的函数都是栅栏函数的话，那么这个队列虽然本身是并行队列，但实际效果是串行队列的效果。在dispatch_barrier_async中分别删除callbackBlocks和URLOperations中和token所对应的对象。</p><h5 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h5><p>首先，SDWebImageDownloaderOperation是继承于NSOperation的，把其加入一个队列中，就会自动执行，这是NSOperation的特点。这里的SDWebImageDownloaderOperation是一个自定义NSOperation，自定义NSOperation需要自己实现start方法，自己维护isFinished和isExecuting等属性。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)start</div></pre></td></tr></table></figure><p>在start方法里，大致做了生成unownedSession，dataTask，执行dataTask等工作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.dataTask resume]</div></pre></td></tr></table></figure><p>在开始执行之后，进行调用保存在callbackBlocks中的所有progressBlock，并且设置self.executing = YES。最后发送通知SDWebImageDownloadStartNotification，表示任务已经开始。</p><p>同时也要实现done函数，表示任务执行完毕。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)done &#123;</div><div class="line">    <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">self</span>.executing = <span class="literal">NO</span>;</div><div class="line">    [<span class="keyword">self</span> reset];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一个小tips：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@synthesize</span> finished = _finished;</div><div class="line">- (<span class="keyword">void</span>)setFinished:(<span class="built_in">BOOL</span>)finished &#123;</div><div class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];</div><div class="line">    _finished = finished;</div><div class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样写的好处是，当我们设置当前的finished时，我们相当于设置了isFinished，所有对其的KVO都会生效。</p><h5 id="一些阅读代码过程中的tips"><a href="#一些阅读代码过程中的tips" class="headerlink" title="一些阅读代码过程中的tips"></a>一些阅读代码过程中的tips</h5><ul><li>使用@synchronized保证线程安全，下面的例子中就是相当于对runningOperations加了锁，保证的其在不同线程访问是不会产生错误。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        [<span class="keyword">self</span>.runningOperations addObject:operation];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;重读SDWebImage&quot;&gt;&lt;a href=&quot;#重读SDWebImage&quot; class=&quot;headerlink&quot; title=&quot;重读SDWebImage&quot;&gt;&lt;/a&gt;重读SDWebImage&lt;/h4&gt;&lt;p&gt;很早以前刚接触iOS开发的时候就知道SDWebImage的强
      
    
    </summary>
    
    
  </entry>
  
</feed>
