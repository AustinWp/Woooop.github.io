<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 重读SDWebImage · 武小鹏的博客</title><meta name="description" content="重读SDWebImage - Wooop"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="武小鹏的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/MrJingZhi" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Woooop" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">重读SDWebImage</h1><div class="post-info">Sep 18, 2017</div><div class="post-content"><h4 id="重读SDWebImage"><a href="#重读SDWebImage" class="headerlink" title="重读SDWebImage"></a>重读SDWebImage</h4><p>很早以前刚接触iOS开发的时候就知道SDWebImage的强大和流行，在大部分的iOS项目中都可以看到她的身影，也是相当经典的第三方库，非常值得阅读，只是一直以来都只是大致了解其运行的流程，并没有深入阅读源码，其中的许多设计和细节都非常值得学习，所以让我们再次去一探究竟。</p>
<p>首先我们从一张时序图来了解SDWebImage最主要的工作流程。<img src="/2017/09/18/重读SDWebImage/SDWebImageSequenceDiagram.png" alt=""></p>
<p>其工作流程可以分为下列的步骤：</p>
<ol>
<li>控件调用setImageWithURL接口</li>
<li>追溯到UIView的loadImageWithURL方法</li>
<li>在SDWebImageManager中首先通过queryDiskCacheForKey方法寻找所请求的图片是否在沙盒中缓存</li>
<li>如果有，则直接返回Image，否则通过downloadImage方法使用另外一个类SDWebImageDownloader下载图片，返回结果后，通过storeImage缓存图片，而后再返回Image</li>
<li>把Image数据set到相应的控件上</li>
</ol>
<p>了解了基本流程后，我们再看看具体的类结构。<img src="/2017/09/18/重读SDWebImage/SDWebImageClassDiagram.png" alt=""></p>
<p>初看起来是比较复杂的一张类图，但仔细看看后可以发现其实他们之间的关系是比较清晰的。</p>
<ul>
<li>首先我们从左上角开始看起，对UIButton、UIImageView等控件添加分类方法作为下载图片的入口，所有的方法最终走他们父类UIview的方法sd_internalSetImage</li>
<li>SDWebImageManager 作为连接所有类的核心，在sd_internalSetImage方法中通过调用loadImageWithURL进入。</li>
<li>SDWebImageCombinedOperation 描述的是一个在Manager层面的下载操作，里面包含了取消block还有真正的下载操作Operation。</li>
<li>SDWebImageManagerDelegate 提供一些代理方法给外部使用</li>
<li>SDImageCache 看其名字就知道是提供缓存功能的</li>
<li>SDImageCacheConfig 配置缓存设置信息的属性及方法</li>
<li>SDWebImageDownloader 看其名字也知道是用来下载图片的</li>
<li>SDWebImageDownloaderOperation 一个真正的下载任务</li>
<li>SDWebImageDownloadToken 用来描述一个下载任务的特征</li>
<li>SDWebImageDownloaderOperationInterface 如果想要自定义一个下载任务的话，必须遵守的协议</li>
<li>SDWebImagePrefetcher 用来预下载图片的，可以下载完先不使用</li>
</ul>
<p>这么多类中，其实支撑SDWebImage运作的最主要的三个部分，他们分别是：SDWebImageManager、SDImageCache、SDWebImageDownloader下面我们逐一对其进行细细分析，看看他们到底是怎么工作的。</p>
<h5 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h5><p>如果我们查看SDWebImageManager.m的源码，会发现其中近一半多的篇幅都被单独一个方法占据了，他就是之前我们提过的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url options:(SDWebImageOptions)options progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<p>很明显这个方法中的内容是SDWebImageManager中最核心的工作流程，下面我们逐一梳理其中的逻辑。</p>
<ol>
<li><p>检查URL的合法性</p>
</li>
<li><p>检查URL是否曾经失败过</p>
</li>
<li><p>结合上面的信息，选择是否提前回调。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>] url:url];</div></pre></td></tr></table></figure>
</li>
<li><p>根据URL获取CacheKey，通过CacheKey去本地寻找图片，现在内存中找，如果内存中没有就去沙盒中找，这里使用了GCD异步函数，专门在一个IO线程里做沙盒存取的操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock &#123;</div><div class="line">    <span class="comment">// First check the in-memory cache...</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="built_in">NSData</span> *diskData = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">if</span> ([image isGIF]) &#123;</div><div class="line">            diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(image, diskData, SDImageCacheTypeMemory);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="comment">// do not call the completion if cancelled</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>如果缓存中有，则回调，没有的话则去网络下载</p>
<p> 这里有个值得一说的点就是作者通过位移运算符做SDWebImageDownloaderOptions的枚举值，通过对枚举值进行或运算可以通过一个值描述多个枚举。</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SDWebImageDownloaderLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">0</span> <span class="comment">//00000001</span></div><div class="line">SDWebImageDownloaderProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">1</span> <span class="comment">//00000010</span></div><div class="line">SDWebImageDownloaderUseNSURLCache = <span class="number">1</span> &lt;&lt; <span class="number">2</span> <span class="comment">//00000100</span></div><div class="line">options =  SDWebImageDownloaderLowPriority || SDWebImageDownloaderProgressiveDownload || SDWebImageDownloaderUseNSURLCache</div><div class="line">options = <span class="number">00000111</span></div></pre></td></tr></table></figure>
<p> 设置好配置信息后去网络下载</p>
</li>
<li><p>如果下载成功后就把图片cache起来，然后回调</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">	[<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];&#125;</div><div class="line">[<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</div></pre></td></tr></table></figure>
</li>
</ol>
<p>以上就是SDWebImageManager的主要功能和流程，在这其中包含了对imageCache和imageDownloader的调用，下面我们就先说一说imageCache。</p>
<h5 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h5><p>其实SDImageCache的功能很简单，就是对图片的缓存，缓存有两个地方，一个是内存memory，另外一个是沙盒disk。SDImageCache分别提供了对这两个地方进行图片的存、取、删的功能。我们就通过逐一介绍这些方法作为切入点对SDImageCache进行分析。</p>
<ul>
<li><p>存储Store</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</div><div class="line">         imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</div><div class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</div><div class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</div><div class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock;</div></pre></td></tr></table></figure>
<p>这些参数都很好理解，如果cacheconfig中设置了缓存在内存中，则先回把数据缓存进内存，然后再缓存至disk沙盒中。[self checkIfQueueIsIOQueue]检查当前queue是不是IOqueue。然后再把数据写入对应的路径中。</p>
</li>
<li><p>取Query</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock;</div></pre></td></tr></table></figure>
<p>最主要的方法就是这个，其中先去内存中寻找，如果没有命中，则异步去disk中再找，如果找到的话，则把当前图片缓存在内存里方便下一次寻找的的同时，返回图片。</p>
</li>
<li><p>删除Remove</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key fromDisk:(<span class="built_in">BOOL</span>)fromDisk withCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion</div></pre></td></tr></table></figure>
<p>删除逻辑就比较简单了，如果是cacheconfig是shouldCacheImagesInMemory的话，先删除内存中的，再异步删除disk中的数据，然后跳回主线程执行回调。</p>
</li>
</ul>
<h5 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h5><p>在SDWebImage中另一个非常重要的部分就是下载器SDWebImageDownloader了，总体其使用了NSURLSession和NSOperation进行设计和实现。下面这个方法就是整个下载器最主要的了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url options:(SDWebImageDownloaderOptions)options progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock;</div></pre></td></tr></table></figure>
<p>这个方法首先会转入一个新的方法addProgressCallback，并且直接返回其的返回值。在addProgressCallback中会根据URL去URLOperations里面寻找是否有对应的Operation,没有的话，则把createCallback赋值给Operation。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">operation = createCallback();</div></pre></td></tr></table></figure>
<p>并且加入到数组URLOperations中保存。在URLOperations的完成回调函数里写，在Operation执行完毕后，从URLOperations中删除。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line">token = [SDWebImageDownloadToken new];</div><div class="line">token.url = url;</div><div class="line">token.downloadOperationCancelToken = downloadOperationCancelToken;</div></pre></td></tr></table></figure>
<p>通过addHandlersForProgress方法，把过程回调progressBlock和完成回调completedBlock封装在一个downloadOperationCancelToken里面，并且在callbackBlocks中保存。然后再生成一个SDWebImageDownloadToken，分别包含URL和Token信息。最终返回Token</p>
<p>那么到这里，让我们看看前面createCallback()中到底做了什么？</p>
<p>在createCallback()中，我们根据options设置了request的缓存策略</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLRequestCachePolicy</span> cachePolicy = <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>;</div><div class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderUseNSURLCache) &#123;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123;</div><div class="line">                cachePolicy = <span class="built_in">NSURLRequestReturnCacheDataDontLoad</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                cachePolicy = <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>生成了request，设置requestheader，cookies</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval];</div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</div><div class="line">        <span class="keyword">if</span> (sself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders <span class="keyword">copy</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.HTTPHeaders;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>根据request和session生成SDWebImageDownloaderOperation。对Operation的一些属性进行设置，例如credentials（认证），queuePriority（队列中优先级）等等。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</div></pre></td></tr></table></figure>
<p>最后加入到downloadQueue队列中，并且添加上一个加入的lastAddedOperation对当前Operation的依赖。保证先进后出的顺序。（可以想象一下，你快速刷新Tableview的时候，同时有很多图片下载，但是如果是FIFO的话，你已经在底部了，图片还是从上往下，按照请求的顺序返回是不是不合理，合理的应该是你当前眼睛看到的那部分图片，也就是最后发出的那些请求先返回，这样就很好理解了。）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[sself.downloadQueue addOperation:operation];</div><div class="line">        <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            [sself.lastAddedOperation addDependency:operation];</div><div class="line">            sself.lastAddedOperation = operation;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>最后返回operation。</p>
<p>此外，还有另外一个方法，就是取消任务的功能。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)cancel:(<span class="keyword">nullable</span> SDWebImageDownloadToken *)token</div></pre></td></tr></table></figure>
<p>首先进入到dispatch_barrier_async中执行任务，栅栏函数的作用是，在其队列中，保证在其之前的所有任务都执行完毕后才会执行，并且在其执行完毕后，后面的其他任务才能正常执行。倘若一个队列中所有的函数都是栅栏函数的话，那么这个队列虽然本身是并行队列，但实际效果是串行队列的效果。在dispatch_barrier_async中分别删除callbackBlocks和URLOperations中和token所对应的对象。</p>
<h5 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h5><p>首先，SDWebImageDownloaderOperation是继承于NSOperation的，把其加入一个队列中，就会自动执行，这是NSOperation的特点。这里的SDWebImageDownloaderOperation是一个自定义NSOperation，自定义NSOperation需要自己实现start方法，自己维护isFinished和isExecuting等属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)start</div></pre></td></tr></table></figure>
<p>在start方法里，大致做了生成unownedSession，dataTask，执行dataTask等工作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.dataTask resume]</div></pre></td></tr></table></figure>
<p>在开始执行之后，进行调用保存在callbackBlocks中的所有progressBlock，并且设置self.executing = YES。最后发送通知SDWebImageDownloadStartNotification，表示任务已经开始。</p>
<p>同时也要实现done函数，表示任务执行完毕。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)done &#123;</div><div class="line">    <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">self</span>.executing = <span class="literal">NO</span>;</div><div class="line">    [<span class="keyword">self</span> reset];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个小tips：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@synthesize</span> finished = _finished;</div><div class="line">- (<span class="keyword">void</span>)setFinished:(<span class="built_in">BOOL</span>)finished &#123;</div><div class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];</div><div class="line">    _finished = finished;</div><div class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样写的好处是，当我们设置当前的finished时，我们相当于设置了isFinished，所有对其的KVO都会生效。</p>
<h5 id="一些阅读代码过程中的tips"><a href="#一些阅读代码过程中的tips" class="headerlink" title="一些阅读代码过程中的tips"></a>一些阅读代码过程中的tips</h5><ul>
<li>使用@synchronized保证线程安全，下面的例子中就是相当于对runningOperations加了锁，保证的其在不同线程访问是不会产生错误。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        [<span class="keyword">self</span>.runningOperations addObject:operation];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/18/同一台电脑配置多个SSHKey/" class="prev">PREV</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">Wooop</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>